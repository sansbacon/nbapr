{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nbapr is a python-based player rater for nba fantasy. It uses simulation rather than the typical z-score approach used by ESPN and other sites. The output is the average amount of fantasy points a player contributes to a team (or in a specific category). This information is much more useful than a sum of z-scores which are not tied to any real values. It also accounts for the fact that a player's effect on a team is capped by the bounds of being first or last in a category. Z-scores know nothing about fantasy scoring rules, so they continue to penalize or reward a player in a category beyond the practical effect the player could have on team results. Documentation : https://sansbacon.github.io/nbapr/ Source Code : https://github.com/sansbacon/nbapr The key nbapr features are: Fast : takes advantage of pandas and numpy to run 50,000 simulations in less than 30 second. Interpretable results : nbapr ties stats to fantasy points by simulating numerous leagues of players. This is a more useful and comprehensible metric than a sum of z-scores across categories. Better results : Z-score based player raters are very sensitive to outliers and the initial selection of the player pool and tend to assign too much weight to players who dominate or tank a single category. Positional value : future iterations of nbapr will enforce position constraints, and thus give more insight than z-scores into relative position value. Pythonic : library is easy to use and extend as long as you are familiar with data analysis in python (pandas and numpy). Requirements \u00b6 Python 3.8+ pandas 1.0+ numpy 1.19+ requests 2.0+ Installation \u00b6 $ pip install nbapr Example \u00b6 Create It \u00b6 # example python code License \u00b6 This project is licensed under the terms of the MIT license.","title":"nbapr"},{"location":"#requirements","text":"Python 3.8+ pandas 1.0+ numpy 1.19+ requests 2.0+","title":"Requirements"},{"location":"#installation","text":"$ pip install nbapr","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#create-it","text":"# example python code","title":"Create It"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"history-design-future/","text":"Inspiration and Design \u00b6 nbapr was inspired by a mid-2000s article written by Dan Rosenbaum, who was then an economics professor at UNC-Greensboro. He was playing fantasy basketball for the first time and decided to simulate the results of a season to assess the value of different players. At the time, the only measure was the ESPN Player Rater, which uses z-scores to assess player value by category, and then sums those z-scores to get an overall rating. The problem with z-scores is that they are sensitive to outliers and the initial composition of the player pool. Consider the following example for blocked shots during the 2019-20 NBA season, which shows how the values vary substantially by changing the composition of the player pool. If we calculate z-scores for the entire player population, the values look like this player blk blkz Hassan Whiteside 196 7.16 Brook Lopez 163 5.82 Anthony Davis 143 5.01 Rudy Gobert 135 4.68 Myles Turner 132 4.56 Mitchell Robinson 119 4.03 Kristaps Porzingis 115 3.87 Jakob Poeltl 95 3.06 JaVale McGee 94 3.02 Robert Covington 93 2.98 Andre Drummond 93 2.98 Bam Adebayo 93 2.98 Jarrett Allen 92 2.94 Jaren Jackson Jr. 92 2.94 Nerlens Noel 91 2.90 LaMarcus Aldridge 87 2.74 Mo Bamba 86 2.69 Daniel Theis 84 2.61 Maxi Kleber 83 2.57 Dwight Howard 79 2.41 If we limit the player pool to those who have played at least 500 minutes, the values look like this player blk blkz Hassan Whiteside 196 6.23 Brook Lopez 163 5.01 Anthony Davis 143 4.27 Rudy Gobert 135 3.97 Myles Turner 132 3.86 Mitchell Robinson 119 3.37 Kristaps Porzingis 115 3.23 Jakob Poeltl 95 2.48 JaVale McGee 94 2.45 Bam Adebayo 93 2.41 Andre Drummond 93 2.41 Robert Covington 93 2.41 Jarrett Allen 92 2.37 Jaren Jackson Jr. 92 2.37 Nerlens Noel 91 2.34 LaMarcus Aldridge 87 2.19 Mo Bamba 86 2.15 Daniel Theis 84 2.08 Maxi Kleber 83 2.04 Dwight Howard 79 1.89 And if we limit the player pool to 1500 minutes (~20 MPG), they are as follows player blk blkz Hassan Whiteside 196 5.08 Brook Lopez 163 4.04 Anthony Davis 143 3.41 Rudy Gobert 135 3.16 Myles Turner 132 3.06 Kristaps Porzingis 115 2.53 Andre Drummond 93 1.83 Bam Adebayo 93 1.83 Robert Covington 93 1.83 Jarrett Allen 92 1.80 Jaren Jackson Jr. 92 1.80 LaMarcus Aldridge 87 1.64 Daniel Theis 84 1.55 Maxi Kleber 83 1.52 Jonas Valanciunas 76 1.30 Montrezl Harrell 72 1.17 Steven Adams 67 1.01 Giannis Antetokounmpo 66 0.98 Joel Embiid 65 0.95 Al Horford 61 0.83","title":"Inspiration and Design"},{"location":"history-design-future/#inspiration-and-design","text":"nbapr was inspired by a mid-2000s article written by Dan Rosenbaum, who was then an economics professor at UNC-Greensboro. He was playing fantasy basketball for the first time and decided to simulate the results of a season to assess the value of different players. At the time, the only measure was the ESPN Player Rater, which uses z-scores to assess player value by category, and then sums those z-scores to get an overall rating. The problem with z-scores is that they are sensitive to outliers and the initial composition of the player pool. Consider the following example for blocked shots during the 2019-20 NBA season, which shows how the values vary substantially by changing the composition of the player pool. If we calculate z-scores for the entire player population, the values look like this player blk blkz Hassan Whiteside 196 7.16 Brook Lopez 163 5.82 Anthony Davis 143 5.01 Rudy Gobert 135 4.68 Myles Turner 132 4.56 Mitchell Robinson 119 4.03 Kristaps Porzingis 115 3.87 Jakob Poeltl 95 3.06 JaVale McGee 94 3.02 Robert Covington 93 2.98 Andre Drummond 93 2.98 Bam Adebayo 93 2.98 Jarrett Allen 92 2.94 Jaren Jackson Jr. 92 2.94 Nerlens Noel 91 2.90 LaMarcus Aldridge 87 2.74 Mo Bamba 86 2.69 Daniel Theis 84 2.61 Maxi Kleber 83 2.57 Dwight Howard 79 2.41 If we limit the player pool to those who have played at least 500 minutes, the values look like this player blk blkz Hassan Whiteside 196 6.23 Brook Lopez 163 5.01 Anthony Davis 143 4.27 Rudy Gobert 135 3.97 Myles Turner 132 3.86 Mitchell Robinson 119 3.37 Kristaps Porzingis 115 3.23 Jakob Poeltl 95 2.48 JaVale McGee 94 2.45 Bam Adebayo 93 2.41 Andre Drummond 93 2.41 Robert Covington 93 2.41 Jarrett Allen 92 2.37 Jaren Jackson Jr. 92 2.37 Nerlens Noel 91 2.34 LaMarcus Aldridge 87 2.19 Mo Bamba 86 2.15 Daniel Theis 84 2.08 Maxi Kleber 83 2.04 Dwight Howard 79 1.89 And if we limit the player pool to 1500 minutes (~20 MPG), they are as follows player blk blkz Hassan Whiteside 196 5.08 Brook Lopez 163 4.04 Anthony Davis 143 3.41 Rudy Gobert 135 3.16 Myles Turner 132 3.06 Kristaps Porzingis 115 2.53 Andre Drummond 93 1.83 Bam Adebayo 93 1.83 Robert Covington 93 1.83 Jarrett Allen 92 1.80 Jaren Jackson Jr. 92 1.80 LaMarcus Aldridge 87 1.64 Daniel Theis 84 1.55 Maxi Kleber 83 1.52 Jonas Valanciunas 76 1.30 Montrezl Harrell 72 1.17 Steven Adams 67 1.01 Giannis Antetokounmpo 66 0.98 Joel Embiid 65 0.95 Al Horford 61 0.83","title":"Inspiration and Design"},{"location":"nbapr-reference/","text":"pr_traditional ( pool , statscols = ( 'WFGP' , 'FTM' , 'FG3M' , 'REB' , 'AST' , 'STL' , 'BLK' , 'TOV' , 'PTS' )) \u00b6 Traditional player rater Parameters: Name Type Description Default pool DataFrame the player pool dataframe required statscols Iterable[str] the stats columns ('WFGP', 'FTM', 'FG3M', 'REB', 'AST', 'STL', 'BLK', 'TOV', 'PTS') Returns: Type Description DataFrame pd.DataFrame with columns player[str], pts[float] Source code in nbapr/nbapr.py def pr_traditional ( pool : pd . DataFrame , statscols : Iterable [ str ] = ( 'WFGP' , 'FTM' , 'FG3M' , 'REB' , 'AST' , 'STL' , 'BLK' , 'TOV' , 'PTS' ), ) -> pd . DataFrame : \"\"\"Traditional player rater Args: pool (pd.DataFrame): the player pool dataframe statscols (Iterable[str]): the stats columns Returns: pd.DataFrame with columns player[str], pts[float] \"\"\" pool = pool . dropna () stats = pool . loc [:, statscols ] . values pts = np . sum ( _zscore ( stats ), axis = 1 ) # return results return pd . DataFrame ({ 'player' : pool . PLAYER_NAME , 'pos' : pool . POS , 'team' : pool . TEAM , 'pr_zscore' : pts }) rankdata ( a , method = 'average' , * , axis = None ) \u00b6 Assign ranks to data, dealing with ties appropriately. Parameters: Name Type Description Default a ndarray the array of values to be ranked. required method str {'average', 'min', 'max', 'dense', 'ordinal'}, optional 'average' axis Optional[int] Union[None, int], optional None Returns: Type Description ndarray ndarray Size equal to the size of a , containing rank scores. Source code in nbapr/nbapr.py def rankdata ( a : np . ndarray , method : str = 'average' , * , axis : Union [ None , int ] = None ) -> np . ndarray : \"\"\"Assign ranks to data, dealing with ties appropriately. Args: a (np.ndarray): the array of values to be ranked. method (str): {'average', 'min', 'max', 'dense', 'ordinal'}, optional axis: Union[None, int], optional Returns: ndarray Size equal to the size of `a`, containing rank scores. \"\"\" # NOTE: this is from scipy 1.6.0 to avoid importing full library # not a problem on local machine but slows github builds if method not in ( 'average' , 'min' , 'max' , 'dense' , 'ordinal' ): raise ValueError ( 'unknown method \" {0} \"' . format ( method )) if axis is not None : a = np . asarray ( a ) if a . size == 0 : # The return values of `normalize_axis_index` are ignored. The # call validates `axis`, even though we won't use it. # use scipy._lib._util._normalize_axis_index when available np . core . multiarray . normalize_axis_index ( axis , a . ndim ) dt = np . float64 if method == 'average' else np . int_ return np . empty ( a . shape , dtype = dt ) return np . apply_along_axis ( rankdata , axis , a , method ) arr = np . ravel ( np . asarray ( a )) algo = 'mergesort' if method == 'ordinal' else 'quicksort' sorter = np . argsort ( arr , kind = algo ) inv = np . empty ( sorter . size , dtype = np . intp ) inv [ sorter ] = np . arange ( sorter . size , dtype = np . intp ) if method == 'ordinal' : return inv + 1 arr = arr [ sorter ] obs = np . r_ [ True , arr [ 1 :] != arr [: - 1 ]] dense = obs . cumsum ()[ inv ] if method == 'dense' : return dense # cumulative counts of each unique value count = np . r_ [ np . nonzero ( obs )[ 0 ], len ( obs )] if method == 'max' : return count [ dense ] if method == 'min' : return count [ dense - 1 ] + 1 # average method return .5 * ( count [ dense ] + count [ dense - 1 ] + 1 )","title":"nbapr"},{"location":"nbapr-reference/#nbapr.nbapr.pr_traditional","text":"Traditional player rater Parameters: Name Type Description Default pool DataFrame the player pool dataframe required statscols Iterable[str] the stats columns ('WFGP', 'FTM', 'FG3M', 'REB', 'AST', 'STL', 'BLK', 'TOV', 'PTS') Returns: Type Description DataFrame pd.DataFrame with columns player[str], pts[float] Source code in nbapr/nbapr.py def pr_traditional ( pool : pd . DataFrame , statscols : Iterable [ str ] = ( 'WFGP' , 'FTM' , 'FG3M' , 'REB' , 'AST' , 'STL' , 'BLK' , 'TOV' , 'PTS' ), ) -> pd . DataFrame : \"\"\"Traditional player rater Args: pool (pd.DataFrame): the player pool dataframe statscols (Iterable[str]): the stats columns Returns: pd.DataFrame with columns player[str], pts[float] \"\"\" pool = pool . dropna () stats = pool . loc [:, statscols ] . values pts = np . sum ( _zscore ( stats ), axis = 1 ) # return results return pd . DataFrame ({ 'player' : pool . PLAYER_NAME , 'pos' : pool . POS , 'team' : pool . TEAM , 'pr_zscore' : pts })","title":"pr_traditional()"},{"location":"nbapr-reference/#nbapr.nbapr.rankdata","text":"Assign ranks to data, dealing with ties appropriately. Parameters: Name Type Description Default a ndarray the array of values to be ranked. required method str {'average', 'min', 'max', 'dense', 'ordinal'}, optional 'average' axis Optional[int] Union[None, int], optional None Returns: Type Description ndarray ndarray Size equal to the size of a , containing rank scores. Source code in nbapr/nbapr.py def rankdata ( a : np . ndarray , method : str = 'average' , * , axis : Union [ None , int ] = None ) -> np . ndarray : \"\"\"Assign ranks to data, dealing with ties appropriately. Args: a (np.ndarray): the array of values to be ranked. method (str): {'average', 'min', 'max', 'dense', 'ordinal'}, optional axis: Union[None, int], optional Returns: ndarray Size equal to the size of `a`, containing rank scores. \"\"\" # NOTE: this is from scipy 1.6.0 to avoid importing full library # not a problem on local machine but slows github builds if method not in ( 'average' , 'min' , 'max' , 'dense' , 'ordinal' ): raise ValueError ( 'unknown method \" {0} \"' . format ( method )) if axis is not None : a = np . asarray ( a ) if a . size == 0 : # The return values of `normalize_axis_index` are ignored. The # call validates `axis`, even though we won't use it. # use scipy._lib._util._normalize_axis_index when available np . core . multiarray . normalize_axis_index ( axis , a . ndim ) dt = np . float64 if method == 'average' else np . int_ return np . empty ( a . shape , dtype = dt ) return np . apply_along_axis ( rankdata , axis , a , method ) arr = np . ravel ( np . asarray ( a )) algo = 'mergesort' if method == 'ordinal' else 'quicksort' sorter = np . argsort ( arr , kind = algo ) inv = np . empty ( sorter . size , dtype = np . intp ) inv [ sorter ] = np . arange ( sorter . size , dtype = np . intp ) if method == 'ordinal' : return inv + 1 arr = arr [ sorter ] obs = np . r_ [ True , arr [ 1 :] != arr [: - 1 ]] dense = obs . cumsum ()[ inv ] if method == 'dense' : return dense # cumulative counts of each unique value count = np . r_ [ np . nonzero ( obs )[ 0 ], len ( obs )] if method == 'max' : return count [ dense ] if method == 'min' : return count [ dense - 1 ] + 1 # average method return .5 * ( count [ dense ] + count [ dense - 1 ] + 1 )","title":"rankdata()"},{"location":"player-rater-8cat/","text":"var url = \"https://raw.githubusercontent.com/sansbacon/nbapr/main/data/player-rater-8cat.json\"; $(document).ready(function() { var oTable = $('#pr').DataTable( { \"ajax\": url, \"iDisplayLength\": 250, \"dom\": '<\"pull-left\"f><\"pull-right\"l>t', \"order\": [3, 'desc'], \"columnDefs\": [ {\"className\": \"dt-center\", \"targets\": \"_all\"} ] } ); $.fn.dataTable.ext.errMode = 'none'; $('#pr') .on( 'error.dt', function ( e, settings, techNote, message ) { console.log( 'An error has been reported by DataTables: ', message ); alert('Request failed: please use valid values'); }).DataTable(); }); NBA Player Rater: 8 Category \u00b6 Player Pos Team Points PR Traditional Player Pos Team Points PR Traditional","title":"8 Cat Player Rater"},{"location":"player-rater-8cat/#nba-player-rater-8-category","text":"Player Pos Team Points PR Traditional Player Pos Team Points PR Traditional","title":"NBA Player Rater: 8 Category"},{"location":"player-rater-9cat/","text":"var url = \"https://raw.githubusercontent.com/sansbacon/nbapr/main/data/player-rater-9cat.json\"; $(document).ready(function() { var oTable = $('#pr').DataTable( { \"ajax\": url, \"iDisplayLength\": 250, \"dom\": '<\"pull-left\"f><\"pull-right\"l>t', \"order\": [3, 'desc'], \"columnDefs\": [ {\"className\": \"dt-center\", \"targets\": \"_all\"} ] } ); oTable.$('th').tooltip( { \"delay\": 0, \"track\": true, \"fade\": 250 } ); $.fn.dataTable.ext.errMode = 'none'; $('#pr') .on( 'error.dt', function ( e, settings, techNote, message ) { console.log( 'An error has been reported by DataTables: ', message ); alert('Request failed: please use valid values'); }).DataTable(); }); NBA Player Rater: 9 Category \u00b6 Player Pos Team Points PR Traditional Player Pos Team Points PR Traditional","title":"9 Cat Player Rater"},{"location":"player-rater-9cat/#nba-player-rater-9-category","text":"Player Pos Team Points PR Traditional Player Pos Team Points PR Traditional","title":"NBA Player Rater: 9 Category"},{"location":"player-rater-9catftm/","text":"var url = \"https://raw.githubusercontent.com/sansbacon/nbapr/main/data/player-rater-9catftm.json\"; $(document).ready(function() { var oTable = $('#pr').DataTable( { \"ajax\": url, \"iDisplayLength\": 250, \"dom\": '<\"pull-left\"f><\"pull-right\"l>t', \"order\": [3, 'desc'], \"columnDefs\": [ {\"className\": \"dt-center\", \"targets\": \"_all\"} ] } ); oTable.$('th').tooltip( { \"delay\": 0, \"track\": true, \"fade\": 250 } ); $.fn.dataTable.ext.errMode = 'none'; $('#pr') .on( 'error.dt', function ( e, settings, techNote, message ) { console.log( 'An error has been reported by DataTables: ', message ); alert('Request failed: please use valid values'); }).DataTable(); }); NBA Player Rater: 9 Category (Free Throws Made, not FT%) \u00b6 Player Pos Team Points PR Traditional Player Pos Team Points PR Traditional","title":"9 Cat FTM Player Rater"},{"location":"player-rater-9catftm/#nba-player-rater-9-category-free-throws-made-not-ft","text":"Player Pos Team Points PR Traditional Player Pos Team Points PR Traditional","title":"NBA Player Rater: 9 Category (Free Throws Made, not FT%)"},{"location":"table/","text":"Player Pos Team Points PR Traditional Player Pos Team Points PR Traditional","title":"Table"}]}